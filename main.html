<!doctype html> 
<html lang="en">
<head> 
    <meta charset="UTF-8" />
    <title>Phaser - Making your first game, part 1</title>
    <script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(1024, 768, Phaser.AUTO, '', { preload: preload, create: create, update: update });

function preload() {

    game.load.image('sky', 'assets/sky.png');
    game.load.image('ground', 'assets/platform.png');
    game.load.image('star', 'assets/star.png');
    game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
    game.load.image('earth, assets/earth.png');

    // Troll
    game.load.image('plane', 'assets/plane.png');
    game.load.image('birch', 'assets/birch.png');

    // ToAdd
    game.load.image('turret', 'assets/plane.png');
    game.load.image('enemy', 'assets/firstaid.png')
    game.load.image('shadow', 'assets/plane.png');
    game.load.image('plane', 'assets/plane.png');
    game.load.image('plane', 'assets/plane.png');





}

var background;          // group
var platforms;           // group
var stars;               // group
var player;              // instance
var cursors;             // freaking cursors

var enemies;
var enemiesTotal = 0;
var enemiesAlive = 0;



var score = 0;
var scoreText;

function create() {

    /* +++++++++++++++++++++++ Game params ++++++++++++++++++++++*/
    game.physics.startSystem(Phaser.Physics.ARCADE); // arcade

    game.world.setBounds(0, 0, 1024*10, 768);

    // Group of everything movable
    everything_movable = game.add.group();


    /* +++++++++++++++++++++++ BACKGROUND ++++++++++++++++++++++*/

    // Create background group
    background = game.add.group();
    background.enableBody = true;

    // Create background
    var sky = background.create(0, 0, 'sky');
    sky.scale.setTo(2, 2);
    sky.body.immovable = true;

    //game.add.sprite(0, 0, 'sky');

    /* +++++++++++++++++++++++ POINTS COUNT ++++++++++++++++++++++*/

    cursors = game.input.keyboard.createCursorKeys();
    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
    debug = game.add.text(500, 16, 'Actual debugging output', { fontSize: '32px', fill: '#000' });

    /* ++++++++++++++++++++++++ GROUND +++++++++++++++++++++++*/

    // Platforms group
    platforms = game.add.group();
    platforms.enableBody = true;

    // Create ground
    //var ground = game.add.tileSprite(0, game.world.height - 64, 800, 600, 'earth');
    var ground = platforms.create(0, game.world.height - 64, 'ground');
    ground.scale.setTo(1000, 2);
    ground.body.immovable = true;

    /* ++++++++++++++++++++++++ ENEMIES +++++++++++++++++++++++*/
    
    //tank = game.add.sprite(0, 0, 'tank', 'tank1');
    //tank.anchor.setTo(0.5, 0.5);
    //game.physics.enable(tank, Phaser.Physics.ARCADE);
    //tank.body.drag.set(0.2);
    //tank.body.maxVelocity.setTo(400, 400);
    //tank.body.collideWorldBounds = true;
    
    enemies = [];
    enemiesTotal = 20;
    enemiesAlive = 20;


    //  The enemies bullet group
    enemyBullets = game.add.group();
    enemyBullets.enableBody = true;
    enemyBullets.physicsBodyType = Phaser.Physics.ARCADE;
    enemyBullets.createMultiple(100, 'bullet');
    
    enemyBullets.setAll('anchor.x', 0.5);
    enemyBullets.setAll('anchor.y', 0.5);
    enemyBullets.setAll('outOfBoundsKill', true);
    enemyBullets.setAll('checkWorldBounds', true);

    
    for (var i = 0; i < enemiesTotal; i++)
    {
        enemies.push(new EnemyTank(i, game, player, enemyBullets));
    }
    

    /* ++++++++++++++++++++++++ SPRITES +++++++++++++++++++++++*/

    // debug.text = num_obstackles;
    // debug.text = i;


    // Create birches to crash
    var birch_array = [
        [11000, 254, 0.5, 0.5],
        [21200, 254, 0.5, 0.5],
        [31300, 254, 0.5, 0.5],
        [41500, 254, 0.5, 0.5],
        [51650, 254, 0.5, 0.5],
        [61800, 554, 0.5, 0.5],
    ]

    var num_birch = birch_array.length;

    for(var i = 0; i < num_birch; i++)
    {
        ledge = platforms.create(birch_array[i][0], birch_array[i][1], 'birch');
        ledge.scale.setTo(birch_array[i][2], birch_array[i][3]);
        ledge.body.immovable = true;
    }

    // Stars group
    stars = game.add.group();
    stars.enableBody = true;

    //  Here we'll create 12 of them evenly spaced apart
    for (var i = 0; i < 12; i++)
    {
        var star = stars.create(i * 70, 0, 'star');
        star.body.gravity.y = 1000;
        star.body.bounce.y = 0.7 + Math.random() * 0.2;
    }


    /* ++++++++++++++++++++++++ PLAYER +++++++++++++++++++++++*/

    // Creating player
    player = game.add.sprite(0, game.world.height - 200, 'plane')
    player.scale.setTo(0.1, 0.1);

    game.physics.arcade.enable(player);

    //  Player physics properties.
    player.body.bounce.y = 0.0;
    player.body.gravity.y = 80;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    //  player.animations.add('left', [0, 1, 2, 3], 10, true);
    //  player.animations.add('right', [5, 6, 7, 8], 10, true);


    /* ++++++++++++++++++++++++ CAMERA SETTINGS +++++++++++++++++++++++*/
    player.anchor.x = 0.5;
    game.camera.follow(player, Phaser.Camera.FOLLOW_LOCKON, 0.1);
    sky.fixedToCamera = true;
    scoreText.fixedToCamera = true;
    prevCamX = game.camera.x;

}

function update() {

    //  Collide the player and the stars with the platforms
    game.physics.arcade.collide(player, platforms);
    game.physics.arcade.collide(stars, platforms);

    game.physics.arcade.overlap(player, stars, collectStar, null, this);
    game.physics.arcade.overlap(enemyBullets, player, bulletHitPlayer, null, this);

    enemiesAlive = 0;

    
    for (var i = 0; i < enemies.length; i++)
    {
        if (enemies[i].alive)
        {
            enemiesAlive++;
            game.physics.arcade.collide(player, enemies[i].tank);
            game.physics.arcade.collide(platforms, enemies[i].tank);


            //game.physics.arcade.overlap(bullets, enemies[i].tank, bulletHitEnemy, null, this);
            //enemies[i].update();
        }
    }
    


    /*+++++++++++++ PLAYER IDLE +++++++++++++*/

    if (player.body.velocity.x < 0 && !cursors.left.isDown && !cursors.right.isDown)
    {
        player.body.velocity.x -= (player.body.velocity.x / 30);
    }
    else if (player.body.velocity.x > 0 && !cursors.left.isDown && !cursors.right.isDown)
    {
        player.body.velocity.x -= (player.body.velocity.x / 30);;
    }

    /*+++++++++++++ LEFT AND RIGHT MOVEMENT OF PLAYER +++++++++++++*/

    if (cursors.left.isDown)
    {
        player.body.velocity.x += -5;
        player.animations.play('left');

        if (player.body.velocity.x <= -300)
        {
            player.body.velocity.x = -300;
        }
    }

    else if (cursors.right.isDown)
    {
        player.body.velocity.x += 10;
        player.animations.play('right');

        if (player.body.velocity.x >= 600)
        {
            player.body.velocity.x = 600;
        }
    }
    else
    {
        player.animations.stop();
        player.frame = 4;
    }
    
    /*+++++++++++++ UP AND DOWN MOVEMENT OF PLAYER +++++++++++++*/

    if (cursors.up.isDown) //&& player.body.touching.down)
    {
        player.body.velocity.y += -6;
    }

    else if (cursors.down.isDown) //&& player.body.touching.down)
    {
        player.body.velocity.y += 3;
    }

    prevCamX = game.camera.x;

}

function collectStar (player, star) {
    
    // Removes the star from the screen
    star.kill();

    //  Add and update the score
    score += 10;
    scoreText.text = 'Score: ' + score;

}

function bulletHitPlayer (tank, bullet) {

    bullet.kill();

}

EnemyTank = function (index, game, player, bullets) {

    var x = game.world.randomX;
    var y = 500;

    this.game = game;
    this.health = 3;
    this.player = player;
    this.bullets = bullets;
    this.fireRate = 1000;
    this.nextFire = 0;
    this.alive = true;

    this.tank = game.add.sprite(x, y, 'enemy', 'tank1');

    this.tank.anchor.set(0.5);

    this.tank.name = index.toString();
    game.physics.enable(this.tank, Phaser.Physics.ARCADE);
    this.tank.body.immovable = false;
    this.tank.body.collideWorldBounds = true;
    this.tank.body.bounce.setTo(1, 1);

    this.tank.angle = game.rnd.angle();

    game.physics.arcade.velocityFromRotation(this.tank.rotation, 100, this.tank.body.velocity);

};

EnemyTank.prototype.damage = function() {

    this.health -= 1;

    if (this.health <= 0)
    {
        this.alive = false;

        this.shadow.kill();
        this.tank.kill();
        this.turret.kill();

        return true;
    }

    return false;

};

EnemyTank.prototype.update = function() {

    this.shadow.x = this.tank.x;
    this.shadow.y = this.tank.y;
    this.shadow.rotation = this.tank.rotation;

    this.turret.x = this.tank.x;
    this.turret.y = this.tank.y;
    this.turret.rotation = this.game.physics.arcade.angleBetween(this.tank, this.player);

    if (this.game.physics.arcade.distanceBetween(this.tank, this.player) < 300)
    {
        if (this.game.time.now > this.nextFire && this.bullets.countDead() > 0)
        {
            this.nextFire = this.game.time.now + this.fireRate;

            var bullet = this.bullets.getFirstDead();

            bullet.reset(this.turret.x, this.turret.y);

            bullet.rotation = this.game.physics.arcade.moveToObject(bullet, this.player, 500);
        }
    }
};


//////////////////////////////////////

function bulletHitPlayer (tank, bullet) {

    bullet.kill();

}

function bulletHitEnemy (tank, bullet) {

    bullet.kill();

    var destroyed = enemies[tank.name].damage();

    if (destroyed)
    {
        var explosionAnimation = explosions.getFirstExists(false);
        explosionAnimation.reset(tank.x, tank.y);
        explosionAnimation.play('kaboom', 30, false, true);
    }

}

function fire () {

    if (game.time.now > nextFire && bullets.countDead() > 0)
    {
        nextFire = game.time.now + fireRate;

        var bullet = bullets.getFirstExists(false);

        bullet.reset(turret.x, turret.y);

        bullet.rotation = game.physics.arcade.moveToPointer(bullet, 1000, game.input.activePointer, 500);
    }

}

function render () {

    // game.debug.text('Active Bullets: ' + bullets.countLiving() + ' / ' + bullets.length, 32, 32);
    game.debug.text('Enemies: ' + enemiesAlive + ' / ' + enemiesTotal, 32, 32);

}

/////////////////////////////////////////




// ToDo
// Clouds
// shooting ground + rocket
// better models
// multiple heli class
// playable xD

</script>

</body>
</html>

